---
title:  ""  
tags: []
published: false
---


## Takeaways



<style>
      .iframe-container {
        overflow: hidden;        
        padding-top: 50%; <!-- Calculated from the aspect ration of the content (in case of 16:9 it is 9/16= 0.5625) -->
        position: relative;
      }
      .iframe-container iframe { 
         border: 0;
         height: 100%; <!-- Finally, width and height are set to 100% so the iframe takes up 100% of the containers space. -->
         left: 0;
         position: absolute;
         top: 0;
         width: 100%;
         display: block;
         margin: 0 auto; <!-- center image -->
      }
      <!-- 4x3 Aspect Ratio -->
      .iframe-container-4x3 {
        padding-top: 75%;
      }
</style> 

<div class="iframe-container-4x3">
  <p align="center"><iframe src="https://avoidboringpeople.substack.com/embed" frameborder="0" scrolling="no"> </iframe></p>
</div>

## 1. Abstracting away layers of work

I'll be discussing the financial technology company [Plaid](https://plaid.com/ "plaid") today. Before that, it would help to get some intuition on abstraction and Application Programming Interfaces (APIs). I'll spend section 1 on abstraction and section 2 on APIs; skip ahead to section 3 if you're already familiar with those concepts. As usual, I'll err on the side of being less technically accurate for easier understanding. 

We'll first discuss abstraction:

Suppose you have a groundbreaking app idea to make lots of money. You code your app such that every time a person presses their keyboard's F2 key, stuff happens and they make a profit:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_1.png)

You test this on your laptop, all works well, and you start raking in cash. It works so well that you tell all your friends about it, who want in on it too. You send them the code and tell them to go forth and prosper. 

One of your friends (the annoying hipster one) tells you that the code doesn't work on his Mac, and he's sad he can't make money for his next single origin single barrel single plant cup of coffee. You wonder why, and go troubleshoot the code.

Turns out Macs have this weird [Touch Bar thing](https://support.apple.com/en-gb/guide/mac-help/mchlbfd5b039/mac "touch") for function keys, whose sole purpose as far as you can tell seems to be to make life miserable. You add in special code for Mac users:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_2.png)

It works for him now, and he moves on to [suing magazines for saying all hipsters look alike.](https://www.independent.co.uk/news/media/hipster-magazine-photo-lawsuit-mit-technology-review-a8813941.html "hipster")

Another friend asks if you can also support mobile phones, to make money on the go. Someone else asks if you can add Blackberry support. And yet another wants to know when the app will be available for the [KFC gaming console](https://www.bbc.com/news/business-55433318 "kfc"). 

As you stare at these tasks of adding more code for all the different computing devices out there, you start to despair. Why can't making money be as easy as pushing a button? **You just want to write your code once, and then be able to use it across multiple devices.**

The idea above is actually a common problem in computing (multiple device support, not the money making one). If you write software that is meant to do everything, you'll need to account for all possible end user devices. After your code is translated to binary (1s and 0s), it needs to still do the same thing. Devices all have their own quirks, and you'll spend more time dealing with exceptions than writing the main functionality. 

In the late 90s people realised a solution to this - add an additional layer in between, aka **make it someone else's problem.** [As Shimon Schocken explains,](https://www.youtube.com/watch?v=E28KczysecE "Shimon") having a "middleman" now simplifies your task. Instead of writing code for every possible device, you "write once, run anywhere", and let that middleman deal with making your code compatible \[1\]:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_3.png)

**Splitting one big task into smaller tasks makes it easier for everyone.** You've abstracted away part of the problem, since you want to write "high level" code and not worry about specific implementation bugs. Others may actually like the "low level" implementation details, but don't want to code the apps on top of it. From each according to his ability, to each according to his needs and all that jazz.

We'll come back to this idea of abstraction, which lets people focus on just specific portions of a task.

Now, suppose you and your friends want to put all of that money into banks around the world. The banks all have different procedures, and will kick you out if you don't follow their rules:

- The New York location just wants you to say your account number, password, and order, [banning you if you talk too much](https://www.youtube.com/watch?v=euLQOQNVzgY "soup")
- The San Francisco location won't serve you unless you display at least 5 company stickers on your laptop
- The Singapore location wants to know when you're expecting to get married and have children for the sake of the country

Most of the group hates memorising all these rules, but April is an exception. She delights in handling esoteric options, and volunteers to deal with all the banks on behalf of the group. Not caring about how your money is deposited and withdrawn, but only that it does get done, the group agrees to let her deal with everything.

You're talking with some acquaintances, and mention this bizarre arrangement you have. They're intrigued, as they also dislike dealing directly with their banks. They want to know if April would be willing to help them out too. She's happy to do so as long as they pay her a small fee for her time. Word spreads, and pretty soon everyone is using April as an intermediary.

We see again that people cared most about one part of a larger task - the deposits and withdrawals. They were fine with however it got done behind the scenes. Having April around made life easier.

Lastly, suppose you wanted to double check your account balance, just to make sure April isn't embezzling the money to pay for hidden service fees in the AirBNB she's renting. You pull up a spreadsheet program and start typing in the recent deposits:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_4.png)

Being a programmer, you scorn excel and aren't familiar with its features. You're pretty sure you can use the "+" sign to add things up though, and start manually calculating your balance that way:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_5.png)

A hundred cells and an hour later, you're close to being done, when a friend asks you what you're doing. They then explain that the sum() function in excel does exactly what you wanted:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_6.png)

They also tell you about the whole "library" of functions that excel has to help make math easier, such as avg(), count(), etc. The cool thing is that you can expect the same behaviour for that function regardless of whatever device you're using - your Windows laptop, your friend's Mac, your dad's mobile phone. Once you know what the function does and how to call on it, you can save time on portions of your task.

This is another example of how abstracting one layer of work helps increase possibilities. The person who programmed sum() doesn't want to spend her time adding up your deposits for you. Neither do you want to manually add up cells every time to duplicate what sum() does. Each of you focuses on what you want to work on, and are able to produce more things as a result.

## 2. Application Programming Interfaces as contracts

We're now ready to think about Application Programming Interfaces (APIs). Imagine you had programmed a library of math functions, like sum() in the above. Wouldn't it be convenient if you could use those functions in other programs that you write?

And if you can make that library accessible to everyone publicly, then a lot of people could use it to build even more interesting things. You can focus on making your math functions, and others can focus on making apps by using your library as a building block.

As [Joshua Bloch](https://www.youtube.com/watch?v=LzMp6uQbmns "Josh") points out, as early as 1952 people like [David Wheeler](https://en.wikipedia.org/wiki/David_Wheeler_(computer_scientist) "David") \[2\] were already proposing this idea of [having libraries of functions (sub-routines)](http://www.laputan.org/pub/papers/Wheeler.pdf "wheeler"):

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_7.png)

We'll call that library of functions an API \[3\]. Joshua believes that the first use of the term comes from [a 1968 paper by Ira Cotton and Frank Greatorex:](https://www.computer.org/csdl/pds/api/csdl/proceedings/download-article/12OmNyRPgFZ/pdf "ira")

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_8.png)

This touches on many of the concepts we discussed in our examples:

- Abstraction. You don't care how the math functions work, just that they do. Splitting up the big task opens up possibilities for interesting work at every layer
- Hardware independence. By having a layer of abstraction, we can use the API's functions regardless of what device we're using
- Reusability. The library can be used across multiple people who want different things

Our API is a well defined contract, telling us the inputs required and the outputs expected. For example, we want the sum() function to return the total of all input numbers wherever it's used, and not the total in some cases and the average in others.

We also can't expect our APIs to do anything outside of the contract. For example, sum() works in excel, but make_me_money() does not - unless the creator of excel decides to implement that function.

And we trust that the API was programmed correctly, having undergone rigourous testing. For example, the sum() function should give us the same result on the same dataset each time.

Imagine life without any APIs. That would mean you had to start from scratch every time you programmed anything. You'd also have to solve the entire problem by yourself.

The concept of abstraction applies outside of programming too. We all work on one layer of a problem, and rely on the lower "levels" being solved for us already. When you're reading this in your email, you don't care how the email service works, just that it does the things you expect.

## 3. Plaid as an API

We've established what APIs are and why they're important. Now, what does Plaid do?

For those unaware, Plaid is a financial technology company that was [supposed to be bought by Visa for $5bn](https://www.justice.gov/opa/pr/visa-and-plaid-abandon-merger-after-antitrust-division-s-suit-block "plaid"), before abandoning the acquisition due to antitrust issues. Unlike my dating life, getting rejected actually made them *more* valuable, and they're now [rumoured to be raising money at $15bn.](https://www.theinformation.com/articles/plaid-shareholders-field-offers-at-15-billion-after-merger-collapse "15")

Think of April from earlier as an API. Plaid is the API between banks and whatever else wants to use banking data. As the company handling all of the integration work, they enable their customers to build apps on top of them, without worrying about the behind the scenes work required.

If you're building an app that requires interacting with banking data, you could spend your entire time trying to handle the 1001 different quirks that each new bank requires when logging in. Or you could leave that up to Plaid, and actually work on your app instead.

We'll take a quick peek at what this looks like, by following Plaid's Quickstart guide [here](https://plaid.com/docs/quickstart/ "quickstart"). It gives you a couple of files to copy in order to set up a test app on your own computer.

After a day of troubleshooting, multiple computer restarts, and blindly installing what seemed like every possible program out there \[4\]:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_9.png)

I finally got some of it to work, being able to access a website on my computer that connected with a test bank account:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_10.png)

Which allowed me to look at dummy data such as my bank account balances:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_11.png)

Or recent transaction data:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_12.png)

If I ~~wanted to~~ knew how to, I could continue building out an app this way, by using the Plaid API to pull the balance data, log a transaction, and update the balance. At this point though I encountered more bugs and ~~gave up~~ left it for another time.

If I was building a company though, you can imagine how much time I'd save by letting Plaid do all the foundational finance work for me. I don't want to be working on the bank integration problem that's a layer below; that's not exciting for me. I'd rather work on making the shiny stock trading roulette wheel on top of that to fleece people of their money; that's [doing god's work](https://dealbook.nytimes.com/2009/11/09/goldman-chief-says-he-is-just-doing-gods-work/ "god").

If you think about most companies these days as "technology" companies, and then also think about how many of them require "financial" data, you start to get a sense of how large Plaid's opportunity is. It's reasonable to assume that more, not less companies are going to want digital financial integration over time.

Plaid charges companies, not consumers, for usage of the API \[5\]. It [seems to take](https://plaid.com/pricing/ "pricing") a transaction based fee for smaller companies, and a subscription fee for larger companies. By doing the "boring" stuff they've created a win-win situation for themselves and other innovators who are happy to pay them for the convenience.

And once you're using Plaid, it's unlikely you'll switch, since that would involve re-writing a lot of the code that uses Plaid's APIs \[6\]. Remember earlier how we needed the API to be well defined? When the API changes, everything that relies on it has to change as well. Think about how often you change your plumbing.

If that sounds unrealistic, consider Fortran, an early programming language. Its library of functions was [defined in **1958**](http://ed-thelen.org/LaFarr/IBM-FORTRAN-II-704-C28-6000-2-c-1958.pdf "fortran"), and is still being used today. Once implemented, APIs last a long time:

![post]({{ site.url }}{{ site.baseurl }}/assets/images/plaid_api/plaid_13.png)

We covered a lot today - intuition behind abstraction, APIs, and what Plaid does. The main takeaway is that there's a lot of stuff that people don't want to do, and a lot of money to be made doing all that stuff. The newsletter's titled avoid boring people, but in this case building the boring stuff actually is a multibillion business.

### Further resources:

1. [What does Plaid do?](https://technically.substack.com/p/what-does-plaid-do "plaid") by Technically
2. [Fireside chat with Plaid CEO Zach Perret](https://www.youtube.com/watch?v=sgnCs34mopw "youtube") by FirstMark
3. [What is an API?](https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces "red hat") by Red Hat
4. [A brief, opinionated history of the API](https://www.youtube.com/watch?v=LzMp6uQbmns "youtube") by Joshua Bloch
5. [How to build a fintech app in Python using Plaid's banking API](https://www.youtube.com/watch?v=Lv2jIOi2fao "youtube") by Erol Aspromatis

## Shoutouts

1. I met with the founder of [Firstbase,](https://firstbase.io/en "firstbase") which "makes it easy for founders to incorporate in the US no matter where you're located"
2. Got connected with the founders of [brighter](https://www.brightertonic.com/ "brighter"), who are making a "sparkling, low calorie drink with a refreshing taste featuring apple cider vinegar"

## Other

1. [Why working from home will stick.](https://nbloom.people.stanford.edu/sites/g/files/sbiybj4746/f/why_wfh_stick1_0.pdf "wfh") In line with my current belief that we'll go back to office based work, with more work from home days.
2. [What is an IP address?](https://outofips.netlify.app/ "IP")
3. [The sting of poverty](http://archive.boston.com/bostonglobe/ideas/articles/2008/03/30/the_sting_of_poverty/?page=1 "poverty")
4. [How I blew out my knee and came back to win a national championship](https://www.jasonshen.com/2011/blew-out-knee-win-national-championship/ "jason")
5. [Judgement is an exercise in discretion](https://aeon.co/essays/judgment-is-an-exercise-in-discretion-circumstances-are-everything? "judge")

## Footnotes

1. To be more technically accurate, it would be the compiler that has to be compatible with every device, and not the code itself, which is a layer above the compiler. 
2. David is apparently the first person to be awarded a PHD in computer science.
3. Technically it should be the contract itself between the parties that is the interface, but I think lumping it together is easier to understand for a beginner
4. I'm 99% certain the Plaid github folder for python is incorrect, as it has empty index.html files. There's also some weird namespace issue between plaid and plaid-python that I couldn't quite understand but eventually fixed. I don't know why they need to use Docker, which was among the many additional programs required for my stuff to work.
5. I'm sure the companies try to pass on that cost to consumers, but the point here is that the direct customer paying for the service is companies that are making apps that require financial integration
6. I believe this to be the case but lmk if mistaken.

*If you liked this, you'll like [my monthly newsletter.](https://avoidboringpeople.substack.com/ "ABP") Sign up here:*

<div class="iframe-container-4x3">
  <p align="center"><iframe src="https://avoidboringpeople.substack.com/embed" frameborder="0" scrolling="no"> </iframe></p>
</div>
